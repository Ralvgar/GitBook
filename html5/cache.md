# Cache

## How Browser Caching Works <a id="3cbd"></a>

### Case 1: User has not visited the site before <a id="15a9"></a>

The browser won’t have any files cached for the site so it will fetch everything from the server.

![](../.gitbook/assets/image%20%288%29.png)

Below is a snapshot of the resources downloaded when visiting the Wikipedia home page for the first time. The status bar at the bottom shows that 265KB of data was transferred to the browser.

![](../.gitbook/assets/image%20%284%29.png)



### Case 2: User has visited the site before <a id="ad1e"></a>

The browser will retrieve the HTML page from the web server but consult its cache for the static assets \(JavaScript, CSS, images\).

![](../.gitbook/assets/image%20%286%29.png)

We can see the difference cache makes when we refresh the Wikipedia page:

![](../.gitbook/assets/image%20%285%29.png)

The data transferred went down to 928 bytes — that’s 0.3% the size of the initial page load. The Size column shows us that most of the content is pulled from cache.

> _Chrome will pull files from either memory cache or disk cache. Since we didn’t close our browser between Cases 1 & 2, the data was still in memory cache._

## How Does the Browser Know What to Cache? <a id="cc20"></a>

The browser inspects the headers of the HTTP response generated by the web server. There are four headers commonly used for caching:

* ETag
* Cache-Control
* Expires
* Last-Modified

### ETag <a id="9ee8"></a>

The _ETag_ \(or Entity Tag\) is a string that serves as a cache validation token. This is usually a hash of the file contents.

The server can include an ETag in its response, which the browser can then use this in a future request \(after the file has expired\) to determine if the cache contains a stale copy.

If the hash is the same, then the resource hasn’t changed and the server responds with a 304 response code \(Not Modified\) with an empty body. This lets the browser know it’s still safe to use the cached copy.

![](../.gitbook/assets/image%20%287%29.png)



Note that ETag is only used in requests whenever the file has expired from cache.

### Cache-Control <a id="344c"></a>

The _Cache-Control_ header has a number of directives we can set to control cache behavior, expiration, and validation. These can be combined together as well.

**Cache Behavior**

```text
Cache-Control: public
```

public means that the resource can be cached by any cache \(browser, CDN, etc\)

```text
Cache-Control: private
```

private means that the resource can only be cached by the browser

```text
Cache-Control: no-store
```

This tells the browser to always request the resource from the server

```text
Cache-Control: no-cache
```

This one is actually a bit misleading. It doesn’t mean “do not cache”.

This tells the browser to cache the file but not to use it until it checks with the server to validate we have the latest version. This validation is done with the ETag header.

This is commonly used with HTML files since it makes sense for the browser to always check for the latest markup.

**Expiration**

```text
Cache-Control: max-age=60
```

This specifies the length of time in seconds the resource should be cached.So a _max-age=60_ means that it should be cached for 1 minute. RFC 2616 recommends that the maximum value for should no longer than 1 year \(_max-age=31536000_\).

```text
Cache-Control: s-max-age=60
```

This is only used by intermediate caches like a CDN.

**Validation**

```text
Cache-Control: must-revalidate
```

This tells the cache it must verify the status of the stale resource before using it and expired ones should not be used.

### Expires <a id="5d23"></a>

The _Expires_ header is from the older HTTP 1.0 days but is still used on many sites.

This header field provides an expiration date after which the asset is considered invalid.

```text
Expires: Wed, 25 Jul 2018 21:00:00 GMT
```

> _The browser will ignore this field if there’s a max-age directive in Cache-Control_

### Last-Modified <a id="53d4"></a>

The Last-Modified header is also from the HTTP 1.0 days.

```text
Last-Modified: Mon, 12 Dec 2016 14:45:00 GMT
```

This field contains the date and time the resource was last modified.

### HTML Meta Tag <a id="d35a"></a>

Prior to HTML5, using meta tags inside HTML to specify cache-control was a valid approach:

```text
<meta http-equiv="Cache-control" content="no-cache">
```

Using a meta tag like this is now discouraged and is not valid HTML5. Why? It’s not a good idea because only browsers will be able to parse the meta tag and understand it. Intermediate caches won’t.

So always send caching instructions via HTTP headers.

### HTTP Response <a id="aef9"></a>

Let’s take a look at an sample HTTP response:

```text
Accept-Ranges: bytes
Cache-Control: max-age=3600
Connection: Keep-Alive
Content-Length: 4361
Content-Type: image/png
Date: Tue, 25 Jul 2017 17:26:16 GMT
ETag: "1109-554221c5c8540"
Expires: Tue, 25 Jul 2017 18:26:16 GMT
Keep-Alive: timeout=5, max=93
Last-Modified: Wed, 12 Jul 2017 17:26:05 GMT
Server: Apache
```

* Line 2 tells us that the max-age is 1 hour
* Line 5 tells us that this is a PNG image
* Line 7 shows us the ETag value which will be used for validation after the 1 hour mark to verify that the resource hasn’t changed
* Line 8 is the Expires header which will be ignored since max-age is set
* Line 10 is the Last-Modified header which shows when the image was last modified

